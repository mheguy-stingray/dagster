---
title: Asset versioning and caching | Dagster Docs
---

# Asset versioning and caching

This guide demonstrates how to build memoizable graphs of assets. Memoizable assets help avoid unnecessary recomputation, speed up the developer workflow, and save computational resources.

---

# Context

There's no reason to spend time materializing an asset if the result is going to be the same as the result of its last materialization.

Dagster's versioning system helps you determine ahead of time whether materializing an asset will produce a different result. It's based on the idea that the result of an asset materialization shouldn't change as long as:

- The code used is the same code as the last time the asset was materialized.
- The input data is the same input data as the last time the asset was materialized.

Dagster has two versioning concepts to represent the code and input data used for each materialization:

1. **Code version.** A string that represents the version of the code that computes an asset. This is the `code_version` argument of <PyObject object="asset" decorator="true" />.
2. **Data version.** A string that represents the version of the data represented by the asset. This is represented as a <PyObject object="DataVersion" /> object.

By keeping track of code and data versions, Dagster can predict whether a materialization will actually change the underlying value. This allows it to skip redundant materializations and instead return the previously-computed value. In more technical terms, Dagster offers a limited form of [memoization](https://en.wikipedia.org/wiki/Memoization) for assets-- the last-computed asset value is always cached.

In computationally expensive data pipelining, this approach can yield tremendous benefits.

---

## Step One: Understanding Staleness

By default, Dagster automatically computes a data version for each materialization of a software-defined asset. It does this by hashing a code version together with the data versions of any input assets.

Let's start with a trivial asset that returns a hardcoded number:

```python file=/guides/dagster/asset_versioning_and_caching/vanilla_asset.py
from dagster import asset


@asset
def a_number():
    return 1
```

We materialize it and look at the entry in the Asset Catalog:

<Image
alt="Simple asset data version"
src="/images/guides/asset-versioning-and-caching/simple-asset-in-catalog.png"
width={4064}
height={2488}
/>

You'll notice two hashes labeled `code_version` and `data_version` in the "System tags" section of the materialization details. The code version shown is a copy of the run ID for the run that generated this materialization. Because `a_number` has no user-defined `code_version`, Dagster assumes a different code version on every run, which it represents with the run ID. The `data_version` is also generated by Dagster. It is a hash of the code version together with the data versions of any inputs. Since `a_number` has no inputs, in this case the data version is a hash of the code version only.

If we materialize the asset again, you'll notice that both the code version and data version change. The code version becomes the ID of the new run and the data version a hash of the new code version.

We can improve this situation by setting an explicit code version. Let's add a `code_version` on our asset:

```python file=/guides/dagster/asset_versioning_and_caching/vanilla_asset_with_code_version.py
from dagster import asset


@asset(code_version="v1")
def versioned_number():
    return 1
```

Let's materialize this asset. Now the user-defined code version "v1" is associated with the latest materialization:

<Image
alt="Simple asset data version with code version"
src="/images/guides/asset-versioning-and-caching/simple-asset-with-code-version-in-catalog.png"
width={2662}
height={1748}
/>

Now let's update the code _and_ inform dagster that the code has changed. Do this by changing the code version argument:

```python file=/guides/dagster/asset_versioning_and_caching/vanilla_asset_with_code_version_v2.py
from dagster import asset


@asset(code_version="v2")
def versioned_number():
    return 11
```

Now we reload our definitions:

<Image
alt="Simple asset data version with code version (v2)"
src="/images/guides/asset-versioning-and-caching/simple-asset-with-code-version-in-asset-graph.png"
width={2662}
height={1748}
/>

The asset is now marked as stale. That is because it has not been materialized since the code version was updated. We can see this in both asset graph and the sidebar, where details about the last materialization of a selected node are visible. You can see the code version associated with the last materialization of `versioned_number` is `v1`, but its current code version is `v2`. This is also explained in the tooltip that appears if you hover over the `(i)` icon on the "stale" indicator tag.

`versioned_number` must be materialized again to become up-to-date. If we click on the disclosure triangle on the right side of the "Materialize" button, a "Materialize stale and missing" button appears. Clicking this button will materialize all stale and missing assets in the asset graph. We can use it now to rematerialize `versioned_number`. This should update the latest materialization `code_version` shown in the sidebar to `v2` and bring the asset up-to-date.

---

## Step Two: Staleness with Dependencies

Staleness computation becomes more powerful when there are dependencies in play. Let's add an asset downstream of our first asset.

```python file=/guides/dagster/asset_versioning_and_caching/dependencies_code_version_only.py
from dagster import asset


@asset(code_version="v2")
def versioned_number():
    return 11


@asset(code_version="v1")
def multiplied_number(versioned_number):
    return versioned_number * 2
```

Reload the location in dagit and you'll notice that `multiplied_number` is marked as "Never Materalized". Now click on the "Materialize" disclosure triangle and then "Materialize stale and missing" (the plain "Materialize" button ignores versioning) to materialize.

Note that in the created run, _only_ the step associated with `multiplied_number` is run. The system knows that `versioned_number` is up to date and therefore can safely skip that computation. You can see this on the details page for the run:

<Image
alt="Materialize stale event log"
src="/images/guides/asset-versioning-and-caching/materialize-stale-event-log.png"
width={2662}
height={1748}
/>

Now let's update the `versioned_number` asset-- we'll change its return value and code version:

```python file=/guides/dagster/asset_versioning_and_caching/dependencies_code_version_only_v2.py
from dagster import asset


@asset(code_version="v3")
def versioned_number():
    return 15


@asset(code_version="v1")
def multiplied_number(versioned_number):
    return versioned_number * 2
```

As we saw previously, this will cause `versioned_number` to become stale. But since `multiplied_number` depends on `versioned_number`, it must be recomputed as well, and so is also marked stale. If you hover over the "Stale" tag on `multiplied_number`, you will see the reason for staleness explained-- upstream `versioned_number` has an updated code version:

<Image
alt="Dependencies code version only"
src="/images/guides/asset-versioning-and-caching/dependencies-code-version-only.png"
width={2662}
height={1748}
/>

Click "Materialize stale and missing" to get both assets up-to-date again.

---

## Step Three: Computing your own data versions

A data version is like a fingerprint for the value that an asset represents, i.e. the output of its materialization function. We therefore want our data versions to correspond 1-1 to the possible return values of a materialization function. Dagster auto-generates data versions by hashing the code version together with input data versions. This satisfies the above criterion in many cases, but sometimes a different approach is necessary.

For example, when a materialization function contains an element of randomness, then multiple materializations of the asset with the same code over the same inputs will produce the same data version for different outputs. On the flip side, if we are generating code versions with an automated approach like source-hashing, then materializing an asset after a cosmetic refactor will produce a different data version (which is derived from the code version) but the same output.

Dagster accommodates these and similar scenarios by allowing user code to supply its own data versions. We simply include the data version alongside the returned asset value in an <PyObject object="Output" /> object. Let's update `versioned_number` to do this. For simplicity, we'll use the stringified return value as the data version:

```python file=/guides/dagster/asset_versioning_and_caching/manual_data_versions_1.py
from dagster import DataVersion, Output, asset


@asset(code_version="v4")
def versioned_number():
    value = 20
    return Output(value, data_version=DataVersion(str(value)))


@asset(code_version="v1")
def multiplied_number(versioned_number):
    return versioned_number * 2
```

Because we updated the code version of `versioned_number`, both assets are again stale. Let's materialize them both again to bring them back to fresh. Notice the `DataVersion` of `versioned_number` is now `20`:

<Image
alt="Manual data versions 1"
src="/images/guides/asset-versioning-and-caching/manual-data-versions-1.png"
width={2662}
height={1748}
/>

Let's simulate a cosmetic refactor by updating `versioned_number` again, but without changing the returned value. We bump the code version to `v5` and change `20` to `10 + 10`:

```python file=/guides/dagster/asset_versioning_and_caching/manual_data_versions_2.py
from dagster import DataVersion, Output, asset


@asset(code_version="v5")
def versioned_number():
    value = 10 + 10
    return Output(value, data_version=DataVersion(str(value)))


@asset(code_version="v1")
def multiplied_number(versioned_number):
    return versioned_number * 2
```

Once again, both assets are now marked stale. Dagster doesn't know that `v5` of versioned number will return the same value as `v4`-- it only knows about code versions and data versions. But let's see what happens if we now materialize _only_ `versioned_number`. Select it in the asset graph and click "Materialize". The sidebar shows the latest materialization now has a code_version of `v5`, and the data version is again `20`:

<Image
alt="Manual data versions 2"
src="/images/guides/asset-versioning-and-caching/manual-data-versions-2.png"
width={2662}
height={1748}
/>

Notice that `multiplied_number` is no longer stale, despite the fact that we did not materialize it! Here's what happened-- `versioned_number` is no longer stale, so `multiplied_number` is no longer automatically stale. Dagster then compared the data version of `versioned_number` last used to materializate `multiplied_number` to the current data version of `versioned_number`. Since this comparison shows that the data version of `versioned_number` has not changed, Dagster knows that `multiplied_number` is not stale.

Note that if `versioned_number` had used a Dagster-generated data versions, `multiplied_number` would be stale. The data version of `versioned_number` would have changed due to its updated code version, despite the fact that the returned value did not change. `multiplied_number` would then register as stale based off of the updated data version of `versioned_number`.

---

## Step Four: Staleness with Source Assets

In the real world, data pipelines depend on external upstream data. So far in this tutorial, we haven't used any external data-- we've been substituting hardcoded data in the asset at the root of our graph, and using a code version as a stand-in for the version of that data. We can do better than this.

External data sources in Dagster are modeled by <PyObject object="SourceAsset" displayText="SourceAssets" />. We can add versioning to a `SourceAsset` by making it _observable_. An observable source asset has a user-defined function that computes and returns a data version.

Let's add an <PyObject object="observable_source_asset" decorator="true" /> called `input_number`. This will represent a file written by an external process, upstream of our pipeline:

```python file=/guides/dagster/asset_versioning_and_caching/input_number.txt
29034
```

The body of the `input_number` function computes a hash of the file contents and returns it as a `DataVersion`. We'll set `input_number` as an upstream dependency of `versioned_number`, and have `versioned_number` simply return the value it reads from the file:

```python file=/guides/dagster/asset_versioning_and_caching/observable_source_asset_path_with_non_argument_deps.py
from hashlib import sha256

from dagster import (
    DataVersion,
    Output,
    asset,
    file_relative_path,
    observable_source_asset,
)


def sha256_digest_from_str(string: str) -> str:
    hash_sig = sha256()
    hash_sig.update(bytearray(string, "utf8"))
    return hash_sig.hexdigest()


FILE_PATH = file_relative_path(__file__, "input_number.txt")


@observable_source_asset
def input_number():
    with open(FILE_PATH) as ff:
        return DataVersion(sha256_digest_from_str(ff.read()))


@asset(code_version="v6", non_argument_deps={"input_number"})
def versioned_number():
    with open(FILE_PATH) as ff:
        value = int(ff.read())
        return Output(value, data_version=DataVersion(str(value)))


@asset(code_version="v1")
def multiplied_number(versioned_number):
    return versioned_number * 2
```

Adding an observable source asset to our graph has revealed a new button labeled "Observe Sources":

<Image
alt="Source asset in graph"
src="/images/guides/asset-versioning-and-caching/source-asset-in-graph.png"
width={2662}
height={1748}
/>

We click this button to kick off a run that executes the observation function of `input_number`. Let's look at the entry in the asset catalog for `input_number`:

<Image
alt="Source asset in catalog"
src="/images/guides/asset-versioning-and-caching/source-asset-in-catalog.png"
width={2662}
height={1748}
/>

Note the `data_version` listed here that you computed.

If we return to the asset graph, we see that `versioned_number` and `multiplied_number` are stale. "Materialize all" to bring them up to date.

Finally, let's manually alter the file to simulate the activity of an external process. Change the content of `input_number.txt`:

```python file=/guides/dagster/asset_versioning_and_caching/input_number_v2.txt
15397
```

If we click the "Observe Sources" button again, the downstream assets are again marked stale-- the observation run generated a new data version for `input_number`, because its content changed.

<Note>
  Asset memoization is under very active development. This guide will be updated
  as we roll out new features in the coming weeks.
</Note>
